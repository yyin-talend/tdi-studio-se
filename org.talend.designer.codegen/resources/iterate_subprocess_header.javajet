<%@ jet 
  package="org.talend.designer.codegen.translators" 
  imports="
  org.talend.core.model.process.INode
  org.talend.core.model.temp.ECodePart  
  org.talend.core.model.process.ElementParameterParser
  org.talend.core.model.process.IConnection 
  org.talend.core.model.metadata.IMetadataTable
  org.talend.core.model.metadata.IMetadataColumn 
  org.talend.core.model.process.EConnectionType 
  org.talend.core.model.process.IExternalNode
  org.talend.designer.codegen.config.CodeGeneratorArgument
  org.talend.designer.codegen.config.NodesSubTree
  org.talend.core.model.process.IProcess
  org.talend.core.model.utils.NodeUtil  
  java.util.List
  java.util.Set
  java.util.HashSet
 "
  class="IterateSubProcessHeader"
  skeleton="subprocess_header_java.skeleton"     
%>
<%
CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
INode node = (INode)codeGenArgument.getArgument();
IProcess process = node.getProcess();
 
NodesSubTree subTree = (NodesSubTree) codeGenArgument.getSubTree();
ECodePart codePart = codeGenArgument.getCodePart();
//boolean trace = codeGenArgument.isTrace();
boolean stat = codeGenArgument.isStatistics();

Set<IConnection> connSet =  new HashSet<IConnection>();
connSet.addAll(node.getOutgoingConnections(EConnectionType.FLOW_MAIN));
connSet.addAll(node.getOutgoingConnections(EConnectionType.FLOW_MERGE));

Set<IConnection> iterateConnSet =  new HashSet<IConnection>();
iterateConnSet.addAll(node.getIncomingConnections(EConnectionType.ITERATE));

String iterateNodeName = node.getUniqueName();

List<IConnection> allSubProcessConnection = codeGenArgument.getAllMainSubTreeConnections();
boolean parallelIterate = false;
for (IConnection iterateConn : iterateConnSet) { //1
	
%>
	NB_ITERATE_<%=iterateNodeName %>++;
<%	
	
	parallelIterate = "true".equals(ElementParameterParser.getValue(iterateConn, "__ENABLE_PARALLEL__"));
	if (parallelIterate) {//2
		if (codePart.equals(ECodePart.BEGIN)) {//3
			String rowList=","; 
			for (IConnection conn : allSubProcessConnection) {
				rowList += conn.getUniqueName()+"Struct "+conn.getUniqueName()+",";
			}
			rowList = rowList.substring(0, rowList.length()-1);
%>			
	class <%=node.getUniqueName() %>Thread extends TalendThread {//implements routines.system.TalendThreadPool.PropertySettable
	
		class ThreadedMap extends java.util.HashMap<String, Object> {
			
			private static final long serialVersionUID = 0L;

			public ThreadedMap(java.util.Map<String, Object> globalMap) {
				super(globalMap);
			}

			@Override
			public Object put(String key, Object value) {
				synchronized (<%=process.getName()%>.this.obj) {
					super.put(key, value);
					return <%=process.getName()%>.this.globalMap.put(key, value);
				}
			}
		}	

		private java.util.Map<String, Object> globalMap = null;
		boolean isRunning = false;
<%
			if(!subTree.isMergeSubTree()) {
				List< ? extends IConnection> rootConns = subTree.getRootNode().getOutgoingConnections();
				if ((rootConns!=null)&&(rootConns.size()>0)) {
%>
		<%=createPrivateClassInstance(subTree.getRootNode(), rootConns.get(0).getName(), false)%>
<%
				}
  			} else {  
    			List<INode> sortedMergeBranchStarts = subTree.getSortedMergeBranchStarts();    
    			for (INode startNode : sortedMergeBranchStarts) {
    				List< ? extends IConnection> rootConns = startNode.getOutgoingConnections();
    				if ((rootConns!=null)&&(rootConns.size()>0)) {
%>		  
		<%=createPrivateClassInstance(startNode, rootConns.get(0).getName(), false)%>
<%
					}
				}
    
				List< ? extends IConnection> rootConns = subTree.getMergeNode().getOutgoingConnections();
				if ((rootConns!=null)&&(rootConns.size()>0)) {
%>
		<%=createPrivateClassInstance(subTree.getMergeNode(), rootConns.get(0).getName(), false)%>
<%
				}
			}
			
			String schemaInstanceDeclaration = createPriveClassMethodDeclaration(subTree.getRootNode(), subTree.getRootNode().getOutgoingConnections().get(0).getName(), false, new java.util.HashSet<String>());
			if (schemaInstanceDeclaration.length()>0) {
				schemaInstanceDeclaration = "," + schemaInstanceDeclaration.substring(0,schemaInstanceDeclaration.length()-1); 
			}
%>
	
		public <%=node.getUniqueName() %>Thread(java.util.Map<String, Object> globalMap<%=schemaInstanceDeclaration %>, int threadID) {
			super();
			<%
			for (IConnection connection : allSubProcessConnection) {
        		IMetadataTable table = connection.getMetadataTable();
				List<IMetadataColumn> listColumns = table.getListColumns();
            	for (IMetadataColumn column : listColumns) {
					%>this.<%= connection.getName() %>.<%= column.getLabel() %> = <%= connection.getName() %>.<%= column.getLabel() %>;
	            	<%
        		}
			} 
			%>
			synchronized (<%=process.getName()%>.this.obj) {
				this.globalMap = java.util.Collections.synchronizedMap(new ThreadedMap(globalMap));
			}
			this.globalMap.put("PARALLEL_ITERATOR_THREAD_ID",Integer.toString(threadID));
		}

		
		public void run() {		

			java.util.Map threadRunResultMap = new java.util.HashMap();
			threadRunResultMap.put("errorCode", null);
			threadRunResultMap.put("status", "");
			threadLocal.set(threadRunResultMap);
			
			this.isRunning = true;
			String currentComponent = "";
			try {			
<%
	        	if(stat){
%>
if(execStat){
				runStat.updateStatOnConnection("<%=iterateConn.getUniqueName() %>",0,"exec"+(String)globalMap.get("PARALLEL_ITERATOR_THREAD_ID"));
}				
<%
				}
			}//3	
			continue;
		}else {//2
	      		if(stat){
%>

<%				
				Set<? extends IConnection> allInLineJobConns = NodeUtil.getAllInLineJobConnections(iterateConn.getTarget());
				for (IConnection inLineConn : allInLineJobConns) {
%>
if(execStat){				
           			runStat.updateStatOnConnection("<%=inLineConn.getUniqueName() %>", 3, "exec" + NB_ITERATE_<%=iterateNodeName %>);
}           			
<%        		
				}
%>        		
if(execStat){
				runStat.updateStatOnConnection("<%=iterateConn.getUniqueName() %>", 1, "exec" + NB_ITERATE_<%=iterateNodeName %>);
				//Thread.sleep(1000);
}				
<%
		  		}
		}//2
	}//1
%>
