<%@ jet
	package="org.talend.designer.codegen.translators.common"
	imports="
		java.util.ArrayList
		java.util.Arrays
		java.util.Collections
		java.util.HashMap
		java.util.HashSet
		java.util.List
		java.util.Map
		java.util.Set
		java.util.Vector

		java.util.regex.Matcher
		java.util.regex.Pattern

		org.talend.designer.codegen.config.CodeGeneratorArgument

		org.talend.core.model.process.INode
		org.talend.core.model.process.IProcess
		org.talend.core.model.process.IConnection
		org.talend.core.model.process.IConnectionCategory
		org.talend.core.model.process.ElementParameterParser

		org.talend.core.model.metadata.IMetadataColumn
		org.talend.core.model.metadata.IMetadataTable
		org.talend.core.model.metadata.types.JavaTypesManager
		org.talend.core.model.metadata.types.JavaType

		java.io.UnsupportedEncodingException
		java.net.URLEncoder

	"
	class="Header_additional"
%>
<%
CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
Vector v = (Vector) codeGenArgument.getArgument();
IProcess process = (IProcess) v.get(0);

boolean actAsProvider = !process.getNodesOfType("tESBProviderRequestLoop").isEmpty();
boolean actAsConsumer = !process.getNodesOfType("tESBConsumer").isEmpty();

if (actAsProvider || actAsConsumer
	|| !process.getNodesOfType("tESBProviderResponse").isEmpty()
	|| !process.getNodesOfType("tESBProviderFault").isEmpty()) { %>
	interface ESBProviderCallbackTalendJobInner extends ESBProviderCallback {
		void setCustomProperties(java.util.Map<String, String> props);
		void sendFault(Throwable e);
		void sendBusinessFault(String faultString, org.dom4j.Document faultDetail);
	} <%
}

if (actAsProvider || actAsConsumer) { %>

	private ESBEndpointRegistry registry = null;
	private ESBProviderCallback callback = null;

	public void setEndpointRegistry(ESBEndpointRegistry registry) {
<% if (actAsConsumer) { %>		this.registry = registry;<% } %>
	}

	public void setProviderCallback(ESBProviderCallback callback) {
<% if (actAsProvider) { %>		this.callback = callback;<% } %>
	}


<% if (actAsProvider) {
	// Web Service Provider
	INode tESBProviderRequestNode = process.getNodesOfType("tESBProviderRequestLoop").get(0);
	String tESBProviderRequestNodeCid = tESBProviderRequestNode.getUniqueName();
	tESBProviderRequestNodeCid = tESBProviderRequestNodeCid.replaceAll("_Loop", "");

	String projectName = codeGenArgument.getCurrentProjectName();
	String processName = process.getName();

	String endpointUrl = ElementParameterParser.getValue(tESBProviderRequestNode, "__ENDPOINT_URI__");

	String wsdlLocation = ElementParameterParser.getValue(tESBProviderRequestNode, "__WSDL_LOCATION__");

	String serviceNS = ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_NS__");
	String serviceName = ElementParameterParser.getValue(tESBProviderRequestNode, "__SERVICE_NAME__");
	if ("--DEFAULT--".equals(serviceName)) {
		serviceName = projectName + "_" + processName;
	}

	String portNS = ElementParameterParser.getValue(tESBProviderRequestNode, "__PORT_NS__");
	String portName = ElementParameterParser.getValue(tESBProviderRequestNode, "__PORT_NAME__");
	if ("--DEFAULT--".equals(portName)) {
		portName = serviceName + "_Port";
	}

	String operationName = ElementParameterParser.getValue(tESBProviderRequestNode, "__OPERATION_NAME__");
	String operationNS = ElementParameterParser.getValue(tESBProviderRequestNode, "__OPERATION_NS__");
	if (null == operationNS || operationNS.isEmpty()) {
		operationNS = serviceNS;
	}

	boolean isOneWay = (process.getNodesOfType("tESBProviderFault").isEmpty()
		&& process.getNodesOfType("tESBProviderResponse").isEmpty());
	%>
	public ESBEndpointInfo getEndpoint() {
		return new ESBEndpointInfo() {
			@SuppressWarnings("serial")
			private java.util.Map<String, Object> props = new java.util.HashMap<String, Object>() {{
				// "request-response" or "one-way"
				put("COMMUNICATION_STYLE", "<%=(isOneWay)?"one-way":"request-response"%>");
				put("dataFormat", "PAYLOAD");
				put("portName", "{<%=portNS%>}<%=portName%>");
				put("serviceName", "{<%=serviceNS%>}<%=serviceName%>");
				put("defaultOperationName", "<%=operationName%>");
				put("defaultOperationNameSpace", "<%=operationNS%>");
				put("publishedEndpointUrl", "<%=endpointUrl%>");
			}};

			public String getEndpointKey() {
				return "cxf";
			}

			public String getEndpointUri() {
				// projectName + "_" + processName
				return "<%=projectName%>_<%=processName%>";
			}

			public java.util.Map<String, Object> getEndpointProperties() {
				return props;
			}
		};
	}





/**
 * queued message exchange
 */
public class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;
	private Throwable fault = null;

	public QueuedExchangeContextImpl(T inMsg) {
		this.input = inMsg;
	}

	/**
	 * Don't forget to call this method when you are done
	 * with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInputMessage() {
		return input;
	}

	public void serveOutputMessage(T response) {
		output = response;
	}

	public void serveFault(Throwable fault) {
		this.fault = fault;
	}

	public boolean isFault() {
		return fault != null;
	}

	public T getResponse() {
		return output;
	}

	public Throwable getFault() {
		return fault;
	}
}

/**
 * message exchange controller
 */
public class QueuedMessageHandlerImpl<T> implements ESBProviderCallback {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			// context.serveFault("job pool overflow exceed", null);
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				// context.serveFault("job execution timeout", ie);
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	QueuedExchangeContextImpl<T> currentExchangeContext;

	public T getRequest() throws ESBJobInterruptedException {
		currentExchangeContext = null;
		try {
			currentExchangeContext = (QueuedExchangeContextImpl<T>) queue.take();
		} catch (InterruptedException e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
		return currentExchangeContext.getInputMessage();
	}

	public void sendResponse(Object output) {
		if (null == currentExchangeContext) {
			throw new RuntimeException("sendResponse() invoked before getRequest()");
		}

		if (output instanceof Throwable) {
			// fault
			currentExchangeContext.serveFault((Throwable) output);
		} else {
			// response
			currentExchangeContext.serveOutputMessage((T) output);
		}

		try {
			currentExchangeContext.release();
		} catch (Exception e) {
			// e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
}

/**
 * web service provider implementation
 */
<% if (null == wsdlLocation || wsdlLocation.trim().isEmpty()) { %>
@javax.jws.WebService(
		name = "<%=serviceName%>PortType",
		targetNamespace = "<%=serviceNS%>"
	)
<% } %>
@javax.jws.soap.SOAPBinding(
		parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE
	)
@javax.xml.ws.ServiceMode(
		value = javax.xml.ws.Service.Mode.PAYLOAD
	)
@javax.xml.ws.WebServiceProvider(
<% if (null != wsdlLocation && !wsdlLocation.trim().isEmpty()) { %>
		wsdlLocation="<%=wsdlLocation%>",<% } %>
		targetNamespace="<%=serviceNS%>",
		serviceName="<%=serviceName%>",
		portName="<%=portName%>"
	)
public class ESBProvider_<%=tESBProviderRequestNodeCid%> implements
		javax.xml.ws.Provider<javax.xml.transform.Source> {

	private final javax.xml.ws.WebServiceProvider annotation =
			ESBProvider_<%=tESBProviderRequestNodeCid%>.class.getAnnotation(
					javax.xml.ws.WebServiceProvider.class);
	private final String TARGET_NS = annotation.targetNamespace();
	private final String SERVICE_NAME = annotation.serviceName();
	private final String PORT_NAME = annotation.portName();

	private final javax.xml.namespace.QName serviceName =
			new javax.xml.namespace.QName(TARGET_NS, SERVICE_NAME);
	private final javax.xml.namespace.QName portName =
			new javax.xml.namespace.QName(TARGET_NS, PORT_NAME);
	private final javax.xml.namespace.QName operationName =
			new javax.xml.namespace.QName("<%=operationNS%>", "<%=operationName%>");

	private javax.xml.transform.TransformerFactory factory =
			javax.xml.transform.TransformerFactory.newInstance();
	private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

	@javax.annotation.Resource()
	private javax.xml.ws.WebServiceContext context;

	public ESBProvider_<%=tESBProviderRequestNodeCid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
		this.messageHandler = messageHandler;
	}

<% if (isOneWay) { %>
	@javax.jws.Oneway()
<% } %>
	public javax.xml.transform.Source invoke(javax.xml.transform.Source request) {

		try {
//			javax.xml.namespace.QName operation = (javax.xml.namespace.QName) context
//					.getMessageContext().get(javax.xml.ws.handler.MessageContext.WSDL_OPERATION);
//			javax.xml.namespace.QName port = (javax.xml.namespace.QName) context
//					.getMessageContext().get(javax.xml.ws.handler.MessageContext.WSDL_PORT);
//			javax.xml.namespace.QName service = (javax.xml.namespace.QName) context
//					.getMessageContext().get(javax.xml.ws.handler.MessageContext.WSDL_SERVICE);
//			if (serviceName.equals(service) && portName.equals(port) && operationName.equals(operation)) {
//				// System.out.println("request to implemented operation");
//			} else {
//				throw new RuntimeException("operation not implemented by job");
//			}

			org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
			factory.newTransformer().transform(request, docResult);
			org.dom4j.Document requestDoc = docResult.getDocument();
			// System.out.println("request: " + requestDoc.asXML());

			QueuedExchangeContextImpl<org.dom4j.Document> messageExchange =
					messageHandler.invoke(requestDoc);

			try {
<% if (isOneWay) { %>
				return null;
<% } else { %>
				if (messageExchange.isFault()) {
					throw messageExchange.getFault();
				} else {
					org.dom4j.Document responseDoc = messageExchange.getResponse();
					if (null == responseDoc) {
						throw new RuntimeException("no response provided by Talend job");
					}
					// System.out.println("response: " + responseDoc.asXML());

					return new org.dom4j.io.DocumentSource(responseDoc);
				}
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			throw ex;
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}
	}
}

public class ESBProviderCallbackTalendJobWrapper_<%=tESBProviderRequestNodeCid%> implements ESBProviderCallbackTalendJobInner {

	private final String TNS = ESBProvider_<%=tESBProviderRequestNodeCid%>.class.getAnnotation(
			javax.xml.ws.WebServiceProvider.class).targetNamespace();

	private ESBProviderCallback esbProviderCallback;
	private java.util.Map<String, String> customProperty;

	public ESBProviderCallbackTalendJobWrapper_<%=tESBProviderRequestNodeCid%>(ESBProviderCallback callback) {
		esbProviderCallback = callback;
	}

	public Object getRequest() throws ESBJobInterruptedException {
		return esbProviderCallback.getRequest();
	}

	public void setCustomProperties(java.util.Map<String, String> props) {
		customProperty = props;
	}

	public void sendResponse(Object response) {
		esbProviderCallback.sendResponse(wrapOutput(response));
	}

	public void sendFault(Throwable error) {
		RuntimeException talendJobError;
		if (error instanceof RuntimeException) {
			talendJobError = (RuntimeException) error;
		} else {
			talendJobError = new RuntimeException(
					"Talend job execution error", error);
		}
		esbProviderCallback.sendResponse(talendJobError);
	}

	public void sendBusinessFault(String faultString,
			org.dom4j.Document faultDetail) {

		try {
			javax.xml.soap.SOAPFactory soapFactory =
				javax.xml.soap.SOAPFactory.newInstance();
			javax.xml.soap.SOAPFault soapFault = soapFactory.createFault(
					faultString, new javax.xml.namespace.QName(TNS, "businessFault"));
			if (null != faultDetail) {
				// System.out.println("business fault details: " + faultDoc.asXML());
				// A special version of DOMWriter that does not write xmlns:foo attributes
				org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter() {
					protected void writeNamespace(org.w3c.dom.Element domElement, org.dom4j.Namespace namespace) {
						// Do nothing
					}
				};
				org.w3c.dom.Document faultDetailDom = writer.write(faultDetail);
				soapFault.addDetail().appendChild(
						soapFault.getOwnerDocument().importNode(
								faultDetailDom.getDocumentElement(), true));
			}
			esbProviderCallback.sendResponse(
					wrapOutput(new javax.xml.ws.soap.SOAPFaultException(soapFault)));
		} catch (Exception e) {
			this.sendFault(e);
		}
	}

	private Object wrapOutput(Object output) {
		if (esbProviderCallback instanceof QueuedMessageHandlerImpl) {
			return output;
		}
		return wrapPayload(output, customProperty);
	}
}

class HandlerThread_<%=tESBProviderRequestNodeCid%> extends Thread {

	private javax.xml.ws.Endpoint endpoint;
	QueuedMessageHandlerImpl<org.dom4j.Document> handler;

	String endpointUrl = "<%=endpointUrl%>";

	public HandlerThread_<%=tESBProviderRequestNodeCid%>(
			QueuedMessageHandlerImpl<org.dom4j.Document> handler) {
		this.handler = handler;
	}

	public void run() {

<%
	//http://jira.talendforge.org/browse/TESB-3603 Clean up default port codes
	//String defaultPort = (String) System.getProperties().get("wsHttpPort");
	//if (null == defaultPort || defaultPort.trim().isEmpty()) {
	//	defaultPort = "8088";
	//}
%>
		// test for busy
		java.net.ServerSocket ss = null;
		try {
			java.net.URL endpointURL = new java.net.URL(endpointUrl);
			String host = endpointURL.getHost();
			int port = endpointURL.getPort();
			if ("localhost".equals(host) || host.startsWith("127.0.0")) {
				try {
					ss = new java.net.ServerSocket(port);
				} catch (IOException e) {
					// rethrow exception
					throw new IllegalArgumentException(
							"Cannot start provider with uri: " + endpointUrl + ". Port " + port + " already in use.");
				} finally {
					if (ss != null) {
						try {
							ss.close();
						} catch (IOException e) {
							// ignore
						}
					}
				}
				try {
					// ok, let's doublecheck for silent listeners
					java.net.Socket cs = new java.net.Socket(host, port);
					// if succeed - somebody silently listening, fail!
					cs.close();
					// rethrow exception
					throw new IllegalArgumentException(
							"Cannot start provider with uri: " + endpointUrl + ". Port " + port + " already in use.");
				} catch (IOException e) {
					//ok, nobody listens, proceed
				}
			}
		} catch (java.net.MalformedURLException e) {
			// rethrow exception
			throw new IllegalArgumentException(
					"Cannot start provider with uri: " + endpointUrl + ". Malformed URL.");
		}

		// null - WSDL value should be used
		endpoint = javax.xml.ws.Endpoint.publish(/* null */ endpointUrl, new ESBProvider_<%=tESBProviderRequestNodeCid%>(handler));

		System.out.println("web service [endpoint: " + endpointUrl + "] published");
	}

	public void stopEndpoint() {
		if (null != endpoint) {
			endpoint.stop();
			System.out.println("web service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}





<% } else { // end if (actAsProvider) %>
	public ESBEndpointInfo getEndpoint() {
		return null;
	}
<% } %>

	private Object wrapPayload(Object payload, Object customProperties) {
		java.util.Map<String, Object> outputWrapped = new java.util.HashMap<String, Object>();
		outputWrapped.put("PAYLOAD", payload);
		if (null != customProperties) {
			outputWrapped.put("SAM-PROPS", customProperties);
		}
		return outputWrapped;
	}

<% } // end if (actAsProvider || actAsConsumer) %>



<% // REST
List<? extends INode> httpRequestComponentsList = process.getNodesOfType("tRESTRequestLoop");
if (!httpRequestComponentsList.isEmpty()) {


	final class URITemplateUtils {

		public static final String TEMPLATE_PARAMETERS = "jaxrs.template.parameters";
		public static final String LIMITED_REGEX_SUFFIX = "(/.*)?";
		public static final String FINAL_MATCH_GROUP = "FINAL_MATCH_GROUP";
		private static final String DEFAULT_PATH_VARIABLE_REGEX = "([^/]+?)";
		private static final String CHARACTERS_TO_ESCAPE = ".*+";

		private final String template;
		private final List<String> variables = new ArrayList<String>();
		private final List<String> customVariables = new ArrayList<String>();
		private final Pattern templateRegexPattern;
		private final String literals;
		private final List<UriChunk> uriChunks;

		public URITemplateUtils(String theTemplate) {
			template = theTemplate;
			StringBuilder literalChars = new StringBuilder();
			StringBuilder patternBuilder = new StringBuilder();
			CurlyBraceTokenizer tok = new CurlyBraceTokenizer(template);
			uriChunks = new ArrayList<UriChunk>();
			while (tok.hasNext()) {
				String templatePart = tok.next();
				UriChunk chunk = createUriChunk(templatePart);
				uriChunks.add(chunk);
				if (chunk instanceof Literal) {
					String encodedValue = encodePartiallyEncoded(chunk.getValue(), false);
					String substr = escapeCharacters(encodedValue);
					literalChars.append(substr);
					patternBuilder.append(substr);
				} else if (chunk instanceof Variable) {
					Variable var = (Variable)chunk;
					variables.add(var.getName());
					if (var.getPattern() != null) {
						customVariables.add(var.getName());
						patternBuilder.append('(');
						patternBuilder.append(var.getPattern());
						patternBuilder.append(')');
					} else {
						patternBuilder.append(DEFAULT_PATH_VARIABLE_REGEX);
					}
				}
			}
			literals = literalChars.toString();

			int endPos = patternBuilder.length() - 1;
			boolean endsWithSlash = (endPos >= 0) ? patternBuilder.charAt(endPos) == '/' : false;
			if (endsWithSlash) {
				patternBuilder.deleteCharAt(endPos);
			}
			patternBuilder.append(LIMITED_REGEX_SUFFIX);

			templateRegexPattern = Pattern.compile(patternBuilder.toString());
		}



		public String getLiteralChars() {
			return literals;
		}

		public String getValue() {
			return template;
		}

		/**
		 * List of all variables in order of appearance in template.
		 *
		 * @return unmodifiable list of variable names w/o patterns,
		 * e.g. for "/foo/{v1:\\d}/{v2}" returned list is ["v1","v2"].
		 */
		public List<String> getVariables() {
			return Collections.unmodifiableList(variables);
		}

		/**
		 * List of variables with patterns (regexps). List is subset of elements from {@link #getVariables()}.
		 *
		 * @return unmodifiable list of variables names w/o patterns.
		 */
		public List<String> getCustomVariables() {
			return Collections.unmodifiableList(customVariables);
		}

		private String escapeCharacters(String expression) {

			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < expression.length(); i++) {
				char ch = expression.charAt(i);
				sb.append(isReservedCharacter(ch) ? "\\" + ch : ch);
			}
			return sb.toString();
		}

		private boolean isReservedCharacter(char ch) {
			return CHARACTERS_TO_ESCAPE.indexOf(ch) != -1;
		}




		/**
		 * Creates object form string.
		 *
		 * @param uriChunk stringified uri chunk
		 * @return If param has variable form then {@link Variable} instance is created,
		 * otherwise chunk is treated as {@link Literal}.
		 */
		public UriChunk createUriChunk(String uriChunk) {
			if (uriChunk == null || "".equals(uriChunk)) {
				throw new IllegalArgumentException("uriChunk is empty");
			}
			UriChunk uriChunkRepresentation = new Variable().create(uriChunk);
			if (uriChunkRepresentation == null) {
				uriChunkRepresentation = new Literal().create(uriChunk);
			}
			return uriChunkRepresentation;
		}

		/**
		 * Stringified part of URI. Chunk is not URI segment; chunk can span over multiple URI segments or one URI
		 * segments can have multiple chunks. Chunk is used to decompose URI of {@link URITemplate} into literals
		 * and variables. Example: "foo/bar/{baz}{blah}" is decomposed into chunks: "foo/bar", "{baz}" and
		 * "{blah}".
		 */
		abstract class UriChunk {

			public abstract String getValue();

			@Override
			public String toString() {
				return getValue();
			}
		}

		final class Literal extends UriChunk {
			private String value;

			private Literal() {
				// empty constructor
			}

			public Literal create(String uriChunk) {
				if (uriChunk == null || "".equals(uriChunk)) {
					throw new IllegalArgumentException("uriChunk is empty");
				}
				Literal literal = new Literal();
				literal.value = uriChunk;
				return literal;
			}

			@Override
			public String getValue() {
				return value;
			}

		}

		/**
		 * Variable of URITemplate. Variable has either "{varname:pattern}" syntax or "{varname}".
		 */
		final class Variable extends UriChunk {
			private final Pattern VARIABLE_PATTERN =
					Pattern.compile("(\\w[-\\w\\.]*[ ]*)(\\:(.+))?");
			private String name;
			private Pattern pattern;

			private Variable() {
				// empty constructor
			}

			/**
			 * Creates variable from stringified part of URI.
			 *
			 * @param uriChunk uriChunk chunk that depicts variable
			 * @return Variable if variable was successfully created; null if uriChunk was not a variable
			 */
			public Variable create(String uriChunk) {
				Variable newVariable = new Variable();
				if (uriChunk == null || "".equals(uriChunk)) {
					return null;
				}
				if (insideBraces(uriChunk)) {
					uriChunk = stripBraces(uriChunk).trim();
					Matcher matcher = VARIABLE_PATTERN.matcher(uriChunk);
					if (matcher.matches()) {
						newVariable.name = matcher.group(1).trim();
						if (matcher.group(2) != null && matcher.group(3) != null) {
							String patternExpression = matcher.group(3).trim();
							newVariable.pattern = Pattern.compile(patternExpression);
						}
						return newVariable;
					}
				}
				return null;
			}

			public String getName() {
				return name;
			}

			public String getPattern() {
				return pattern != null ? pattern.pattern() : null;
			}

			@Override
			public String getValue() {
				if (pattern != null) {
					return "{" + name + ":" + pattern + "}";
				} else {
					return "{" + name + "}";
				}
			}
		}

		/**
		 * Splits string into parts inside and outside curly braces. Nested curly braces are ignored and treated
		 * as part inside top-level curly braces. Example: string "foo{bar{baz}}blah" is split into three tokens,
		 * "foo","{bar{baz}}" and "blah". When closed bracket is missing, whole unclosed part is returned as one
		 * token, e.g.: "foo{bar" is split into "foo" and "{bar". When opening bracket is missing, closing
		 * bracket is ignored and taken as part of current token e.g.: "foo{bar}baz}blah" is split into "foo",
		 * "{bar}" and "baz}blah".
		 * <p>
		 * This is helper class for {@link URITemplate} that enables recurring literals appearing next to regular
		 * expressions e.g. "/foo/{zipcode:[0-9]{5}}/". Nested expressions with closed sections, like open-closed
		 * brackets causes expression to be out of regular grammar (is context-free grammar) which are not
		 * supported by Java regexp version.
		 */
		class CurlyBraceTokenizer {

			private List<String> tokens = new ArrayList<String>();
			private int tokenIdx;

			public CurlyBraceTokenizer(String string) {
				boolean outside = true;
				int level = 0;
				int lastIdx = 0;
				int idx;
				for (idx = 0; idx < string.length(); idx++) {
					if (string.charAt(idx) == '{') {
						if (outside) {
							if (lastIdx < idx) {
								tokens.add(string.substring(lastIdx, idx));
							}
							lastIdx = idx;
							outside = false;
						} else {
							level++;
						}
					} else if (string.charAt(idx) == '}' && !outside) {
						if (level > 0) {
							level--;
						} else {
							if (lastIdx < idx) {
								tokens.add(string.substring(lastIdx, idx + 1));
							}
							lastIdx = idx + 1;
							outside = true;
						}
					}
				}
				if (lastIdx < idx) {
					tokens.add(string.substring(lastIdx, idx));
				}
			}

			public boolean hasNext() {
				return tokens.size() > tokenIdx;
			}

			public String next() {
				if (hasNext()) {
					return tokens.get(tokenIdx++);
				} else {
					throw new IllegalStateException("no more elements");
				}
			}
		}

		/**
		 * Token is enclosed by curly braces.
		 *
		 * @param token text to verify
		 * @return true if enclosed, false otherwise.
		 */
		public boolean insideBraces(String token) {
			return token.charAt(0) == '{' && token.charAt(token.length() - 1) == '}';
		}

		/**
		 * Strips token from enclosed curly braces. If token is not enclosed method
		 * has no side effect.
		 *
		 * @param token text to verify
		 * @return text stripped from curly brace begin-end pair.
		 */
		public String stripBraces(String token) {
			if (insideBraces(token)) {
				return token.substring(1, token.length() - 1);
			} else {
				return token;
			}
		}




		// HttpUtils()

		private final Pattern ENCODE_PATTERN =
				Pattern.compile("%[0-9a-fA-F][0-9a-fA-F]");

		// there are more of such characters, ex, '*' but '*' is not affected by UrlEncode
		private static final String PATH_RESERVED_CHARACTERS = "=@/:";
		private static final String QUERY_RESERVED_CHARACTERS = "?/";

		private String componentEncode(String reservedChars, String value) {

			StringBuilder buffer = new StringBuilder();
			StringBuilder bufferToEncode = new StringBuilder();

			for (int i = 0; i < value.length(); i++) {
				char currentChar = value.charAt(i);
				if (reservedChars.indexOf(currentChar) != -1) {
					if (bufferToEncode.length() > 0) {
						buffer.append(urlEncode(bufferToEncode.toString()));
						bufferToEncode.setLength(0);
					}
					buffer.append(currentChar);
				} else {
					bufferToEncode.append(currentChar);
				}
			}

			if (bufferToEncode.length() > 0) {
				buffer.append(urlEncode(bufferToEncode.toString()));
			}

			return buffer.toString();
		}

		public String queryEncode(String value) {

			return componentEncode(QUERY_RESERVED_CHARACTERS, value);
		}

		public String urlEncode(String value) {

			try {
				value = java.net.URLEncoder.encode(value, "UTF-8");
			} catch (java.io.UnsupportedEncodingException ex) {
				// unlikely to happen
			}

			return value;
		}

		public String pathEncode(String value) {

			String result = componentEncode(PATH_RESERVED_CHARACTERS, value);
			// URLEncoder will encode '+' to %2B but will turn ' ' into '+'
			// We need to retain '+' and encode ' ' as %20
			if (result.indexOf('+') != -1) {
				result = result.replace("+", "%20");
			}
			if (result.indexOf("%2B") != -1) {
				result = result.replace("%2B", "+");
			}

			return result;
		}

		public boolean isPartiallyEncoded(String value) {
			return ENCODE_PATTERN.matcher(value).find();
		}

		/**
		 * Encodes partially encoded string. Encode all values but those matching pattern
		 * "percent char followed by two hexadecimal digits".
		 *
		 * @param encoded fully or partially encoded string.
		 * @return fully encoded string
		 */
		public String encodePartiallyEncoded(String encoded, boolean query) {
			if (encoded.length() == 0) {
				return encoded;
			}
			Matcher m = ENCODE_PATTERN.matcher(encoded);
			StringBuilder sb = new StringBuilder();
			int i = 0;
			while (m.find()) {
				String before = encoded.substring(i, m.start());
				sb.append(query ? queryEncode(before) : pathEncode(before));
				sb.append(m.group());
				i = m.end();
			}
			String tail = encoded.substring(i, encoded.length());
			sb.append(query ? queryEncode(tail) : pathEncode(tail));
			return sb.toString();
		}

	}

	/**
	* JAXRS Parameter Representation
	*/
	final class Parameter {
		private String name;
		private String javaType;
		private String paramType;
		private String defaultValue;

		public Parameter(String name, String paramType, String javaType, String defaultValue) {
			this.name = name;
			this.javaType = javaType;
			this.paramType = paramType;
			this.defaultValue = defaultValue;
		}

		public String getName() {
			return name;
		}
		public String getJavaType() {
			return javaType;
		}
		public String getParamType() {
			return paramType;
		}
		public String getDefaultValue() {
			return defaultValue;
		}
	}


	INode tRESTRequestNode = httpRequestComponentsList.get(0);
	String tRESTRequestNodeCid = tRESTRequestNode.getUniqueName();
	tRESTRequestNodeCid = tRESTRequestNodeCid.replaceAll("_Loop", "");
	boolean isOneWayRest = tRESTRequestNode.getProcess().getNodesOfType("tRESTResponse").isEmpty();
%>
/**
 * queued message exchange
 */
class QueuedExchangeContextImpl<T> {

	/**
	 * Exchange timeout in seconds
	 */
	private static final long EXCHANGE_TIMEOUT = 50;

	private final java.util.concurrent.Exchanger<Exception> exceptionExchange =
		new java.util.concurrent.Exchanger<Exception>();
	private final java.util.concurrent.CountDownLatch latch =
		new java.util.concurrent.CountDownLatch(1);

	private final T input;

	private T output = null;

	public QueuedExchangeContextImpl(T input) {
		this.input = input;
	}

	/**
	 * Don't forget to call this method when you are done
	 * with processing of the {@link QueuedExchangeContext}
	 */
	public void release() throws Exception {
		latch.countDown();
		Exception exception;
		try {
			exception = exceptionExchange.exchange(null, EXCHANGE_TIMEOUT,
					java.util.concurrent.TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new Exception(e);
		} catch (java.util.concurrent.TimeoutException e) {
			throw new Exception(e);
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * This operation have to be called on the Web Service
	 * thread to send response if required
	 *
	 * @throws InterruptedException
	 */
	public void completeQueuedProcessing() throws InterruptedException {
		exceptionExchange.exchange(null);
	}

	/**
	 * @throws InterruptedException
	 */
	void waitForRelease(long timeout, java.util.concurrent.TimeUnit unit)
			throws InterruptedException {
		latch.await(timeout, unit);
	}

	public T getInput() {
		return input;
	}

	public void serveOutput(T response) {
		output = response;
	}

	public T getResponse() {
		return output;
	}
}

/**
 * message exchange controller
 */
class QueuedMessageHandlerImpl<T> implements ESBProviderCallback {
	private final int MAX_QUEUE_SIZE = 1000;

	private final int WAIT_TIMEOUT_SECONDS = 120;

	private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue =
		new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(MAX_QUEUE_SIZE);

	/**
	 * This method add a newly created
	 * {@link QueuedExchangeContextImpl} into the internal
	 * blocking queue where consumer thread is waiting for it.
	 * Then it waits until the {@link QueuedExchangeContextImpl}
	 * will be completed for request-response operations
	 */
	public QueuedExchangeContextImpl<T> invoke(T request) {
		QueuedExchangeContextImpl<T> context =
			new QueuedExchangeContextImpl<T>(request);
		boolean inserted = queue.offer(context);
		if (!inserted) {
			try {
				context.release();
			} catch (Exception e) {
				e.printStackTrace();
			}
			throw new RuntimeException(
					"Can't queue request, queue size of "
							+ MAX_QUEUE_SIZE + " is exceeded");
		} else {
			try {
				context.waitForRelease(WAIT_TIMEOUT_SECONDS,
						java.util.concurrent.TimeUnit.SECONDS);
			} catch (InterruptedException ie) {
				throw new RuntimeException(
						"job execution timeout: " + ie.getMessage());
			}
		}
		return context;
	}

	QueuedExchangeContextImpl<T> currentExchangeContext;

	public T getRequest() throws ESBJobInterruptedException {
		currentExchangeContext = null;
		try {
			currentExchangeContext = (QueuedExchangeContextImpl<T>) queue.take();
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}
		return currentExchangeContext.getInput();
	}

	public void sendResponse(Object output) {
		if (null == currentExchangeContext) {
			throw new RuntimeException("sendResponse() invoked before getRequest()");
		}

		currentExchangeContext.serveOutput((T) output);

		try {
			currentExchangeContext.release();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
}

/**
 * A special Dom4J provider implementation to help conversion in JAX-RS
 * @see http://jira.talendforge.org/browse/TESB-3329
 */
@javax.ws.rs.Produces({"application/xml", "application/json" })
@javax.ws.rs.Consumes({"application/xml", "application/json" })
public static class DOM4JProvider implements javax.ws.rs.ext.MessageBodyReader<org.dom4j.Document>, javax.ws.rs.ext.MessageBodyWriter<org.dom4j.Document> {

		private static final Class<org.w3c.dom.Document> DOM_DOC_CLS = org.w3c.dom.Document.class;

		private javax.ws.rs.ext.Providers providers;

		@javax.ws.rs.core.Context
		public void setProviders(javax.ws.rs.ext.Providers providers) {
			this.providers = providers;
		}

		public boolean isReadable(Class<?> cls, java.lang.reflect.Type type, java.lang.annotation.Annotation[] anns,
				javax.ws.rs.core.MediaType mt) {
			return org.dom4j.Document.class.isAssignableFrom(cls);
		}

		public org.dom4j.Document readFrom(Class<org.dom4j.Document> cls, java.lang.reflect.Type type,
				java.lang.annotation.Annotation[] anns, javax.ws.rs.core.MediaType mt,
				javax.ws.rs.core.MultivaluedMap<String, String> headers, java.io.InputStream is)
				throws IOException, javax.ws.rs.WebApplicationException {
			javax.ws.rs.ext.MessageBodyReader<org.w3c.dom.Document> reader =
					providers.getMessageBodyReader(DOM_DOC_CLS, DOM_DOC_CLS, anns, mt);
			if (reader == null) {
				throw new javax.ws.rs.WebApplicationException(415);
			}
			org.w3c.dom.Document domDoc =
					reader.readFrom(DOM_DOC_CLS, DOM_DOC_CLS, anns, mt, headers, is);
			return new org.dom4j.io.DOMReader().read(domDoc);
		}

		public long getSize(org.dom4j.Document doc, Class<?> cls, java.lang.reflect.Type type,
				java.lang.annotation.Annotation[] anns, javax.ws.rs.core.MediaType mt) {
			return -1;
		}

		public boolean isWriteable(Class<?> cls, java.lang.reflect.Type type,
				java.lang.annotation.Annotation[] anns, javax.ws.rs.core.MediaType mt) {
			return org.dom4j.Document.class.isAssignableFrom(cls);
		}

		public void writeTo(org.dom4j.Document doc,Class<?> cls, java.lang.reflect.Type type,
				java.lang.annotation.Annotation[] anns, javax.ws.rs.core.MediaType mt,
				javax.ws.rs.core.MultivaluedMap<String, Object> headers, java.io.OutputStream os)
				throws IOException, javax.ws.rs.WebApplicationException {
			if (mt.getSubtype().contains("xml")) {
				org.dom4j.io.XMLWriter writer = new org.dom4j.io.XMLWriter(os);
				writer.write(doc);
				writer.flush();
			} else {
				 org.w3c.dom.Document domDoc = convertToDOM(doc);

				javax.ws.rs.ext.MessageBodyWriter<org.w3c.dom.Document> writer =
						 providers.getMessageBodyWriter(DOM_DOC_CLS, DOM_DOC_CLS, anns, mt);
				if (writer == null) {
					throw new javax.ws.rs.WebApplicationException(406);
				}
				writer.writeTo(domDoc, DOM_DOC_CLS, DOM_DOC_CLS, anns, mt, headers, os);
			}
		}

		private org.w3c.dom.Document convertToDOM(org.dom4j.Document doc) {
			String xml = doc.asXML();
			try {
				return org.apache.cxf.helpers.DOMUtils.readXml(new java.io.StringReader(xml));
			} catch (Exception ex) {
				throw new javax.ws.rs.WebApplicationException(ex);
			}
		}

}

/**
 * REST provider implementation
 */
@javax.ws.rs.Path("/")
@javax.ws.rs.Produces({"application/xml", "application/json"})
@javax.ws.rs.Consumes({"application/xml", "application/json"})
public class RESTProvider_<%=tRESTRequestNodeCid%> {

	@javax.ws.rs.core.Context private javax.ws.rs.core.UriInfo ui;

	private QueuedMessageHandlerImpl<java.util.Map<String, Object>> messageHandler;

	public RESTProvider_<%=tRESTRequestNodeCid%>(
			QueuedMessageHandlerImpl<java.util.Map<String, Object>> messageHandler) {
		this.messageHandler = messageHandler;
	}


	private javax.ws.rs.core.Response processRequest(java.util.Map<String, Object> request) {
		try {
			QueuedExchangeContextImpl<java.util.Map<String, Object>> messageExchange =
				messageHandler.invoke(request);

			try {
<% if (isOneWayRest) { %>
				// return null;
				return javax.ws.rs.core.Response.status(200).build();
<% } else { %>
				java.util.Map<String, Object> responseMap = messageExchange.getResponse();
				Object responseBody = responseMap.get("BODY");
				Integer status = (Integer) responseMap.get("STATUS");
				if (null == status) {
					if (request.containsKey("STATUS")) {
						status = (Integer) request.get("STATUS");
					} else {
						status = 200;
					}
				}

				return javax.ws.rs.core.Response.status(status).entity(responseBody).build();
<% } %>
			} finally {
				messageExchange.completeQueuedProcessing();
			}

		} catch (RuntimeException ex) {
			ex.printStackTrace();
			throw new javax.ws.rs.WebApplicationException(ex, 500);
		} catch (Throwable ex) {
			ex.printStackTrace();
			throw new javax.ws.rs.WebApplicationException(ex, 500);
		}
	}

<%
List<? extends IConnection> conns = process.getNodesOfType("tRESTRequestIn").get(0).getOutgoingSortedConnections();
if (null != conns && !conns.isEmpty()) {
	List<Map<String, String>> mappings = (List<Map<String, String>>) ElementParameterParser.getObjectValue(tRESTRequestNode, "__SCHEMAS__");
	for (IConnection conn : conns) {
		if (!conn.getLineStyle().hasConnectionCategory(IConnectionCategory.DATA)) {
			continue;
		}

		String connName = conn.getName();
		String httpVerb = null;
		String uriPattern = null;

		boolean foundMapping = false;
		for (Map<String, String> mapping : mappings) {
			String outputConn = mapping.get("SCHEMA");
			if (connName.equals(outputConn)) {
				foundMapping = true;
				httpVerb = mapping.get("HTTP_VERB");
				uriPattern = mapping.get("URI_PATTERN");
			}
		}
		if (!foundMapping) {
			continue;
		}

		boolean formSupported = false;

		// All the parameters specified in the Schema Editor need to be handled.
		final Set<String> paramTypes = new HashSet<String>(Arrays.asList("PATH", "QUERY", "FORM", "HEADER"));

		Map<String, Parameter> parameters = new HashMap<String, Parameter>();
		if (null != uriPattern) {
			URITemplateUtils uriTemplate = new URITemplateUtils(uriPattern);
			List<String> variables = uriTemplate.getVariables();

			IMetadataTable connMetadata = conn.getMetadataTable();
			for (IMetadataColumn column : connMetadata.getListColumns()) {
				// parameter name
				String paramName = column.getLabel();
				if (paramName.equals("body")) {
			            continue;
				}

				// parameter type - if empty - default to 'path'
				String paramType = column.getComment();
				if (paramType == null || paramType.length() == 0) {
					paramType = "PATH";
				} else {
					paramType = paramType.toUpperCase().trim();
				}
				// must be a supported parameter type
				if (!paramTypes.contains(paramType)) {
					// Report unsupported JAX-RS parameter type
					continue;
				}
				// having at least one form parameter means form submissions are supported
				if ("FORM".equals(paramType)) {
					formSupported = true;
				}
				// convert from say "PATH" to "Path"
				paramType = paramType.substring(0, 1) + paramType.substring(1).toLowerCase();

				JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());

				if (JavaTypesManager.STRING == javaType

					|| JavaTypesManager.BOOLEAN == javaType

					|| JavaTypesManager.BYTE == javaType

					// number
					|| JavaTypesManager.SHORT == javaType
					|| JavaTypesManager.INTEGER == javaType
					|| JavaTypesManager.LONG == javaType
					|| JavaTypesManager.FLOAT == javaType
					|| JavaTypesManager.DOUBLE == javaType
					|| JavaTypesManager.BIGDECIMAL == javaType) {

					String javaTypeWhole = JavaTypesManager.getTypeToGenerate(javaType, true);
					// parameter default value
					String defaultValue = column.getDefault();

					Parameter param = new Parameter(paramName, paramType, javaTypeWhole, defaultValue);
					parameters.put(paramName, param);
				} else {
					//Report that the Java type is unsupported
				}
			}
		}
%>
	@javax.ws.rs.<%=httpVerb%>()
<% if (null != uriPattern) { %>
	@javax.ws.rs.Path(<%=uriPattern%>)
<% } %>
<% if (formSupported) { %>
	@javax.ws.rs.Consumes("application/x-www-form-urlencoded")
<% } %>
	public javax.ws.rs.core.Response <%=connName%>(
		<%
			boolean paramCommaWritten = false;
			for (String parameter : parameters.keySet()) {
				Parameter param = parameters.get(parameter);
				if (!paramCommaWritten) {
					paramCommaWritten = true;
				} else {
					%>, <%
				}

				if (param.getDefaultValue() != null) { %>
					@javax.ws.rs.DefaultValue("<%=param.getDefaultValue()%>")
				<% } %>
				@javax.ws.rs.<%=param.getParamType()%>Param("<%=parameter%>") <%=param.getJavaType()%> <%=parameter%>
		<%	} %>
		<% if (!("GET".equals(httpVerb) || "DELETE".equals(httpVerb) || formSupported)) {
			if (paramCommaWritten) {
				%>, <%
			} %>
			org.dom4j.Document body
		<% } %>
			) {

		java.util.Map<String, Object> request = new java.util.HashMap<String, Object>();
		request.put("VERB", "<%=httpVerb%>");
		request.put("OPERATION", "<%=connName%>");
		request.put("PATTERN", <%=uriPattern%>);
		<% if (!("GET".equals(httpVerb) || "DELETE".equals(httpVerb) || formSupported)) { %>
		request.put("BODY", body);
		<% } %>
		request.put("URI", ui.getPath());
		request.put("URI_BASE", ui.getBaseUri().toString());
		request.put("URI_ABSOLUTE", ui.getAbsolutePath().toString());

		//request.put("PARAMS", getPathParameters(uriInfo));
		java.util.Map<String, Object> parameters = new java.util.HashMap<String, Object>();
		<%	for (String parameter : parameters.keySet()) { %>
			parameters.put("<%=parameter%>", <%=parameter%>);
		<%	} %>
		request.put("PARAMS", parameters);

		return processRequest(request);
	}
<%
	}
}
%>
	public javax.ws.rs.core.Response handleWrongRequest(
			org.apache.cxf.jaxrs.ext.MessageContext context, int status, String error) {

		// System.out.println("wrong call [uri: " + context.getUriInfo().getPath() + " ; method: " + context.getRequest().getMethod() + " ; status: " + status + " ; error: " + error + "]");

		java.util.Map<String, Object> wrongRequest = new java.util.HashMap<String, Object>();
		wrongRequest.put("ERROR", error);
		wrongRequest.put("STATUS", status);
		wrongRequest.put("VERB", context.getRequest().getMethod());
		wrongRequest.put("URI", context.getUriInfo().getPath());
		wrongRequest.put("URI_BASE", context.getUriInfo().getBaseUri().toString());
		wrongRequest.put("URI_ABSOLUTE", context.getUriInfo().getAbsolutePath().toString());

		return processRequest(wrongRequest);
	}
}

class RestExceptionMapper_<%=tRESTRequestNodeCid%> extends org.apache.cxf.jaxrs.impl.WebApplicationExceptionMapper {

	@javax.ws.rs.core.Context private org.apache.cxf.jaxrs.ext.MessageContext messageContext;

	private RESTProvider_<%=tRESTRequestNodeCid%> provider;

	public RestExceptionMapper_<%=tRESTRequestNodeCid%>(RESTProvider_<%=tRESTRequestNodeCid%> provider) {
		this.provider = provider;
	}

	public javax.ws.rs.core.Response toResponse(javax.ws.rs.WebApplicationException ex) {
		String error = null;
		javax.ws.rs.core.Response response = ex.getResponse();
		if (null != response && null != response.getEntity()) {
			error = response.getEntity().toString();
		}
		response = super.toResponse(ex);
		if (null == error) {
			if (null != response && null != response.getEntity()) {
				error = response.getEntity().toString();
			} else {
				error = null == ex.getCause() ? ex.getMessage() : ex.getCause().getMessage();
			}
		}
		response = provider.handleWrongRequest(messageContext, response.getStatus(), error);

		java.util.List<javax.ws.rs.core.MediaType> accepts = messageContext.getHttpHeaders().getAcceptableMediaTypes();
		String type = accepts.isEmpty() ? "application/xml" : accepts.get(0).toString();
		return javax.ws.rs.core.Response.status(response.getStatus()).entity(response.getEntity()).type(type).build();
	}
}


class HandlerThread_<%=tRESTRequestNodeCid%> extends Thread {

	private QueuedMessageHandlerImpl<java.util.Map<String, Object>> handler;

	private final String endpointUrl = <%=ElementParameterParser.getValue(tRESTRequestNode, "__REST_ENDPOINT__")%>;

	private org.apache.cxf.endpoint.Server server;

	public HandlerThread_<%=tRESTRequestNodeCid%>(QueuedMessageHandlerImpl<java.util.Map<String, Object>> handler) {
		this.handler = handler;
	}

	public void run() {
		try {
			RESTProvider_<%=tRESTRequestNodeCid%> provider =
					new RESTProvider_<%=tRESTRequestNodeCid%>(handler);

			org.apache.cxf.jaxrs.JAXRSServerFactoryBean sf =
					new org.apache.cxf.jaxrs.JAXRSServerFactoryBean();
			java.util.List<Object> providers = new java.util.ArrayList<Object>();
			providers.add(new RestExceptionMapper_<%=tRESTRequestNodeCid%>(provider));
			providers.add(new DOM4JProvider());
			org.apache.cxf.jaxrs.provider.JSONProvider jsonProvider =
					new org.apache.cxf.jaxrs.provider.JSONProvider();
			jsonProvider.setIgnoreNamespaces(true);
			providers.add(jsonProvider);
			sf.setProviders(providers);
			sf.setTransportId("http://cxf.apache.org/transports/http");
			sf.setResourceClasses(RESTProvider_<%=tRESTRequestNodeCid%>.class);
			sf.setResourceProvider(RESTProvider_<%=tRESTRequestNodeCid%>.class,
					new org.apache.cxf.jaxrs.lifecycle.SingletonResourceProvider(provider));
			sf.setAddress(endpointUrl);
			server = sf.create();

			// System.out.println("REST service [endpoint: " + endpointUrl + "] published");
		} catch (Throwable e) {
			e.printStackTrace();
		}
	}

	public void stopEndpoint() {
		if (null != server) {
			server.stop();
			server.destroy();
			// System.out.println("REST service [endpoint: " + endpointUrl + "] unpublished");
		}
	}
}
<%
}
%>
